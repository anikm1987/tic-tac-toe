<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevent double tap zoom on mobile */
        }
        .cell {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #cbd5e1; /* slate-300 */
            transition: background-color 0.2s ease-in-out;
        }
        .cell:hover:not(.disabled) { /* Only hover effect if not disabled */
            background-color: #f1f5f9; /* slate-100 */
        }
        .cell.disabled {
            cursor: not-allowed;
        }
        .winning-cell {
            background-color: #a7f3d0 !important; /* emerald-200 */
            color: #065f46 !important; /* emerald-800 */
        }
        /* Custom modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        /* Ensure board is centered and scales reasonably on smaller screens */
        .board-container {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0.5rem; /* 8px */
            width: 100%;
            max-width: 320px; /* Adjust as needed */
            margin: 1rem auto;
        }
        @media (max-width: 400px) {
            .cell {
                font-size: 2.5rem; /* Slightly smaller font for very small screens */
            }
            .board-container {
                gap: 0.25rem; /* 4px */
            }
        }
        /* Styling for game mode selection */
        .game-mode-selector label {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.375rem;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .game-mode-selector input[type="radio"]:checked + label {
            background-color: #0ea5e9; /* sky-500 */
            color: white;
            border-color: #0ea5e9; /* sky-500 */
        }
         .game-mode-selector input[type="radio"] {
            display: none; /* Hide the actual radio button */
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-50 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-sky-600">Tic Tac Toe</h1>
        </header>

        <main>
            <div class="game-mode-selector flex justify-center space-x-2 mb-6">
                <input type="radio" id="pvp" name="gameMode" value="pvp" checked>
                <label for="pvp" class="hover:bg-slate-100">Player vs Player</label>

                <input type="radio" id="pvc" name="gameMode" value="pvc">
                <label for="pvc" class="hover:bg-slate-100">Player vs Computer</label>
            </div>

            <div id="status" class="text-center text-xl font-semibold mb-4 h-8 text-slate-700">Player X's turn</div>

            <div id="board" class="board-container">
                </div>

            <div class="mt-8 text-center">
                <button id="resetButton" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50">
                    Restart Game
                </button>
            </div>
        </main>
    </div>

    <div id="messageModal" class="modal-overlay">
        <div class="modal-content">
            <p id="modalMessageText" class="text-2xl font-semibold mb-6"></p>
            <button id="modalCloseButton" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md transition duration-150 ease-in-out">
                Play Again
            </button>
        </div>
    </div>

    <footer class="text-center mt-8 text-slate-500 text-sm">
        <p>Built with HTML, Tailwind CSS, and JavaScript.</p>
    </footer>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const pvpRadio = document.getElementById('pvp');
        const pvcRadio = document.getElementById('pvc');

        // --- Game State ---
        let currentPlayer = 'X'; // Human is always X
        let humanPlayer = 'X';
        let computerPlayer = 'O';
        let boardState = ['', '', '', '', '', '', '', '', ''];
        let gameActive = true;
        let gameMode = 'pvp'; // 'pvp' or 'pvc'

        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // --- Functions ---

        /**
         * Initializes or resets the game board.
         * Clears the board state, resets the current player, and re-renders the cells.
         */
        function initializeGame() {
            currentPlayer = humanPlayer; // Human always starts
            boardState = ['', '', '', '', '', '', '', '', ''];
            gameActive = true;
            gameMode = document.querySelector('input[name="gameMode"]:checked').value;
            
            statusElement.textContent = `Player ${currentPlayer}'s turn`;
            if (gameMode === 'pvc' && currentPlayer === computerPlayer) {
                statusElement.textContent = `Computer (${computerPlayer})'s turn`;
            } else if (gameMode === 'pvc' && currentPlayer === humanPlayer) {
                 statusElement.textContent = `Your (${humanPlayer}) turn`;
            }

            statusElement.className = 'text-center text-xl font-semibold mb-4 h-8 text-slate-700'; // Reset status color
            renderBoard();
            hideModal();

            if (gameMode === 'pvc' && currentPlayer === computerPlayer) {
                // If computer is set to start (e.g. if human was 'O'), make its move.
                // For simplicity, human (X) always starts, so this branch might not be hit initially.
                disableBoardInteraction(true);
                setTimeout(computerMove, 500);
            } else {
                 disableBoardInteraction(false);
            }
        }

        /**
         * Renders the game board cells based on the current boardState.
         * Adds event listeners to each cell for player interaction.
         */
        function renderBoard() {
            boardElement.innerHTML = ''; // Clear previous cells
            boardState.forEach((value, index) => {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'bg-white', 'rounded-md', 'shadow');
                if (value === humanPlayer) {
                    cell.classList.add('text-pink-500');
                } else if (value === computerPlayer) {
                    cell.classList.add('text-blue-500');
                }
                cell.textContent = value;
                cell.dataset.index = index;
                cell.addEventListener('click', handleCellClick);
                cell.addEventListener('touchend', handleCellClick); // For touch devices
                boardElement.appendChild(cell);
            });
        }
        
        /**
         * Disables or enables interaction with the board cells.
         * @param {boolean} disable - True to disable, false to enable.
         */
        function disableBoardInteraction(disable) {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                if (disable) {
                    cell.classList.add('disabled');
                } else {
                    cell.classList.remove('disabled');
                }
            });
        }


        /**
         * Handles a click or tap event on a game cell.
         * If the cell is empty and the game is active, it updates the board state,
         * checks for a win or draw, and switches the player.
         * @param {Event} event - The click or touchend event.
         */
        function handleCellClick(event) {
            event.preventDefault(); // Prevent double event firing on touch
            const clickedCellIndex = parseInt(event.target.dataset.index);

            if (boardState[clickedCellIndex] !== '' || !gameActive || (gameMode === 'pvc' && currentPlayer === computerPlayer)) {
                return; // Cell already taken, game over, or computer's turn
            }

            makeMove(clickedCellIndex, currentPlayer);

            if (!gameActive) return; // Game ended after player's move

            if (gameMode === 'pvc') {
                switchPlayer(); // Switch to computer
                if (gameActive) { // Check if game is still active for computer's move
                    disableBoardInteraction(true);
                    setTimeout(computerMove, 700); // Computer "thinks" for a bit
                }
            } else {
                switchPlayer(); // PvP mode
            }
        }

        /**
         * Processes a move for the given player at the specified index.
         * @param {number} index - The index of the cell to move to.
         * @param {string} player - The player making the move ('X' or 'O').
         */
        function makeMove(index, player) {
            if (boardState[index] !== '' || !gameActive) return;

            boardState[index] = player;
            const cellElement = boardElement.querySelector(`.cell[data-index='${index}']`);
            cellElement.textContent = player;
            if (player === humanPlayer) {
                cellElement.classList.add('text-pink-500');
            } else if (player === computerPlayer) {
                cellElement.classList.add('text-blue-500');
            }

            if (checkWin(player)) {
                gameActive = false;
                highlightWinningCells(player);
                let winnerMessage = `Player ${player} wins!`;
                if (gameMode === 'pvc') {
                    winnerMessage = (player === humanPlayer) ? "You win!" : "Computer wins!";
                }
                showModal(winnerMessage);
                statusElement.textContent = winnerMessage;
                statusElement.className = 'text-center text-xl font-bold mb-4 h-8 text-emerald-600';
                disableBoardInteraction(false); // Re-enable for clarity, though game is over
                return;
            }

            if (checkDraw()) {
                gameActive = false;
                showModal("It's a draw!");
                statusElement.textContent = "It's a draw!";
                statusElement.className = 'text-center text-xl font-bold mb-4 h-8 text-amber-600';
                disableBoardInteraction(false);
                return;
            }
        }
        
        /**
         * Computer AI makes a move.
         * Simple AI: 1. Win, 2. Block, 3. Center, 4. Random Corner, 5. Random Side
         */
        function computerMove() {
            if (!gameActive) return;

            let move = -1;

            // 1. Check for a winning move
            for (let i = 0; i < 9; i++) {
                if (boardState[i] === '') {
                    boardState[i] = computerPlayer;
                    if (checkWin(computerPlayer)) {
                        move = i;
                        boardState[i] = ''; // Reset test move
                        break;
                    }
                    boardState[i] = ''; // Reset test move
                }
            }

            // 2. Check for a blocking move
            if (move === -1) {
                for (let i = 0; i < 9; i++) {
                    if (boardState[i] === '') {
                        boardState[i] = humanPlayer;
                        if (checkWin(humanPlayer)) {
                            move = i;
                            boardState[i] = ''; // Reset test move
                            break;
                        }
                        boardState[i] = ''; // Reset test move
                    }
                }
            }

            // 3. Take center if available
            if (move === -1 && boardState[4] === '') {
                move = 4;
            }

            // 4. Take a random available corner
            if (move === -1) {
                const corners = [0, 2, 6, 8];
                const availableCorners = corners.filter(index => boardState[index] === '');
                if (availableCorners.length > 0) {
                    move = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }
            }

            // 5. Take a random available side
            if (move === -1) {
                const sides = [1, 3, 5, 7];
                const availableSides = sides.filter(index => boardState[index] === '');
                if (availableSides.length > 0) {
                    move = availableSides[Math.floor(Math.random() * availableSides.length)];
                }
            }
            
            // 6. Fallback: take any available spot (should be covered by 4 & 5 but as a safeguard)
             if (move === -1) {
                const availableSpots = boardState.map((val, idx) => val === '' ? idx : -1).filter(idx => idx !== -1);
                if (availableSpots.length > 0) {
                    move = availableSpots[Math.floor(Math.random() * availableSpots.length)];
                }
            }


            if (move !== -1) {
                makeMove(move, computerPlayer);
            }
            
            disableBoardInteraction(false); // Re-enable board for human player
            if(gameActive) switchPlayer(); // Switch back to human if game not over
        }


        /**
         * Checks if the specified player has won the game.
         * @param {string} player - The player to check for a win ('X' or 'O').
         * @returns {boolean} True if the player has a winning combination, false otherwise.
         */
        function checkWin(player) {
            for (const combination of winningCombinations) {
                const [a, b, c] = combination;
                if (boardState[a] === player && boardState[b] === player && boardState[c] === player) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Highlights the cells that form the winning combination for the given player.
         * @param {string} player - The player whose winning cells to highlight.
         */
        function highlightWinningCells(player) {
            for (const combination of winningCombinations) {
                const [a, b, c] = combination;
                if (boardState[a] === player && boardState[b] === player && boardState[c] === player) {
                    document.querySelector(`.cell[data-index='${a}']`).classList.add('winning-cell');
                    document.querySelector(`.cell[data-index='${b}']`).classList.add('winning-cell');
                    document.querySelector(`.cell[data-index='${c}']`).classList.add('winning-cell');
                    break; // Highlight only the first winning combination found
                }
            }
        }

        /**
         * Checks if the game is a draw (all cells are filled and no winner).
         * @returns {boolean} True if the game is a draw, false otherwise.
         */
        function checkDraw() {
            return boardState.every(cell => cell !== '') && !checkWin(humanPlayer) && !checkWin(computerPlayer);
        }

        /**
         * Switches the current player and updates the status display.
         */
        function switchPlayer() {
            currentPlayer = (currentPlayer === humanPlayer) ? computerPlayer : humanPlayer;
            
            if (gameMode === 'pvc') {
                statusElement.textContent = (currentPlayer === humanPlayer) ? `Your (${humanPlayer}) turn` : `Computer (${computerPlayer})'s turn`;
            } else {
                statusElement.textContent = `Player ${currentPlayer}'s turn`;
            }
        }

        /**
         * Shows the custom modal with a given message.
         * @param {string} message - The message to display in the modal.
         */
        function showModal(message) {
            modalMessageText.textContent = message;
            messageModal.classList.add('active');
        }

        /**
         * Hides the custom modal.
         */
        function hideModal() {
            messageModal.classList.remove('active');
        }

        // --- Event Listeners ---
        resetButton.addEventListener('click', initializeGame);
        modalCloseButton.addEventListener('click', initializeGame); // Modal button also resets
        pvpRadio.addEventListener('change', initializeGame);
        pvcRadio.addEventListener('change', initializeGame);


        // --- Initial Game Setup ---
        initializeGame();

        // Add a simple console log to confirm script is running
        console.log("Tic Tac Toe game script loaded and initialized with AI opponent option.");
    </script>
</body>
</html>
